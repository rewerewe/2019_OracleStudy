SELECT USER
FROM DUAL;
--==>> HR


/*
    웹브라우저에 <데이터베이스 정규화> 검색 
    URL : https://blog.naver.com/ronniee27/221488152561
    안봐도 됩니다. 개념은 정리되어 있으나, 읽을수록 더 헷갈림..    
*/

-----------------------------------------------------------------------------------------------------------------
--■■■ 정규화 (Nomalization) ■■■--
/*
    [강사님 설명]
    
    ▶ 정규화는 
    테이블은 나누고 분리하고 쪼개는 것, 
    
    테이블을 쪼개는 것 
    작게 쪼개인 테이블이 위력을 갖는다. 
    나누고 분리하는데 집중하는데 수업의 목표가 있는데, 이와 같습니다. 
    
    ▶ 왜 하나요? 
    데이터 서버의 메모리 낭비를 막기 위해서 

    테이블이 1개로 구성되어 있으면 
    SMITH 사원번호, 사원명만 궁금 할 때 두 가지만 조회하더라도, SMITH의 모든 정보가 메모리에 퍼 올려지기 때문에 
    메모리 낭비가 발생한다.
    
    ▶ 어떻게 하나요?
    (1) 식별자를 갖는 컬럼별로 쪼갠다. 
    (2) 절차와 순서를 정해주었다. 프로세스는 4단계로, 5단계로, 10단계로 구분해놓는 등 학계마다 다를 수 있다.
        우리는 실무에 적용하기 쉬운 단계로 살펴본다.
    (3)
    
        
    [강사님 필기]
    
    ○ 정규화란?
    한마디로 데이터베이스 서버의 메모리 낭비를 막기 위해 
    어떤 하나의 테이블을 식별자를 가지는 여러개의 테이블로 
    나누는 과정을 말한다.
    
    ex) 진석이가... 옥장판을 판매한다.
        고객리스트 → 거래처직원 명단이 적혀있는 수첩이 정보로 
        데이터베이스화 하려고 한다.
    
    테이블명 : 거래처직원 
     
      10Byte        10Byte          10Byte         10Byte      10Byte      10Byte      10Byte
    
    --------------------------------------------------------------------------------------------
     거래처회사명     회사주소      회사전화     거래처직원명      직급      이메일     휴대폰 
    --------------------------------------------------------------------------------------------
         LG         서울 여의도  02-3456-7890      곽한얼         부장     khy@na...    010-....
         LG         서울 여의도  02-3456-7890      권홍비         과장     khb@da...    010-....
         LG         서울 여의도  02-3456-7890      김경환         대리     kkh@ga...    010-....
         LG         서울 여의도  02-3456-7890      김선아         부장     ksa@na...    010-....
         SK         서울 소공동  02-1234-7890      김성희         대리     ksh@na...    010-....
         LG         부산 동래구  051-9999-9999     남상현         대리     nsh@na...    010-....
                                                    :
                                                    :
    --------------------------------------------------------------------------------------------
    
    
    가정) 서울 여의도 LG라는 회사에 근무하는 거래처 직원 명단이 
          총 100만 명이라고 가정한다.
          (한 행(레코드)는 70Byte 이다.)
          
          어느 날... 『서울 여의도』에 위치한 『LG』 본사가 
          『경기 분당』으로 사옥을 이전하게 되었다.
          
          이로 인해...
          회사 주소는 『경기 분당』으로 바뀌고,
          회사 전화는 『031-1111-2222』로 바뀌게 되었다.
          
          그렇기에 100만 명의 회사주소와 회사전화를 변경해야 한다.
          - 이때 수행되어야 할 쿼리문 → UPDATE 구문
          
          UPDATE 거래처직원
          SET 회사주소='경기분당', 회사전화='031-1111-2222'
          WHERE 거래처회사명 = 'LG'
            AND 회사주소 = '서울 여의도';
            
          --> 100만 개 행을 하드디스크상에서 읽어다가 
              메모리에 로드시켜주어야 한다.
              즉, 100만 *70Byte 를 모두 
              하드 디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
          
              --> 이는 테이블의 설계가 잘못되었으므로 
                  DB서버는 조만간 메모리 고갈로 인해 DOWN 될 것이다.
                  
                  --> 그러므로 정규화 과정을 수행해야 한다. 
                  
    
        
        ** 순차적으로 제 1정규화부터 ~ 역정규화까지 거쳐야합니다.   
    ○ 제 1 정규화
       반복해서 등장하는 특정 칼럼을 찾아 조깨준다. 
       (ex. 거래처직원 테이블에서는 '회사정보'과 '직원'으로 데이터의 정보를 구체화 할수 있다.)
       '거래처직원' 테이블은 '회사' 와 '직원' 으로 나뉘어 각각 새 테이블을 만들었다.
       부모와 자식 테이블로 나뉜다.
       
       --> 어떤 하나의 테이블에 반복되는 컬럼 값들이 존재한다면 
           값들이 반복되어 나오는 컬럼을 분리하여 
           새로운 테이블을 만들어준다. 
        
       --> 제 1정규화를 수행하는 과정에서 분리된 테이블은
           반드시 부모 테이블과 자식 테이블의 관계를 갖게 된다.
           
       --> 부모 테이블 → 참조받는 컬럼 → PRIMARY KEY (참조 : 가서 보고 오는 것)
           자식 테이블 → 참조하는 컬럼 → FOREIGN KEY      
            
            ※ 참조 받는 컬럼이 갖는 특징 (부모테이블) → 『프라이머리키 제약조건』 이라 한다. 
               - 반드시 고유한 값(데이터)이 들어와야 한다. 
                 즉, 중복된 값(데이터)이 없어야 한다
               - NULL 이 있어서는 안된다. (NOT NULL 이어야 한다)
               제약조건을 설정해두면, 위반했을 때 오라클에서 강제로 막는다.
 
       --> 제 1 정규화를 수행하는 과정에서 부모 테이블의 PRIMARY KEY 는 
           항상 자식 테이블의 FOREIGN KEY로 전이된다. 
            
                
    
    (1) 테이블명 : 회사  → 부모 테이블 
     
      10Byte     10Byte        10Byte        10Byte 
    
    --------------------------------------------------
     회사ID   거래처회사명     회사주소      회사전화   
     ------
     (참조받는 컬럼 → P.K)
    --------------------------------------------------
       10         LG         서울 여의도  02-3456-7890  
       20         SK         서울 소공동  02-1234-7890  
       30         LG         부산 동래구  051-9999-9999 
    ---------------------------------------------------


    (2) 테이블명 : 직원  → 자식 테이블 
     
       10Byte      10Byte      10Byte      10Byte      10Byte
    
    ---------------------------------------------------------
     거래처직원명      직급      이메일     휴대폰      회사ID
                                                      ------
                                                    (참조하는 컬럼 → F.K)
    ---------------------------------------------------------
        곽한얼        부장     khy@na...    010-....     10
        권홍비        과장     khb@da...    010-....     10
        김경환        대리     kkh@ga...    010-....     10
        김선아        부장     ksa@na...    010-....     10
        김성희        대리     ksh@na...    010-....     20
        남상현        대리     nsh@na...    010-....     30
    ---------------------------------------------------------
                                                        ▲
                                                        90 
                                                        
                                            만약 남상현의 회사 ID 가 90 이라면? 
                                            → 두 개의 테이블이 모두 쓸모없게 된다. 참조의 무결성이 깨기지 때문. 
    
*/
/*

	--※ 테이블이 분할(분리)되기 이전 상태로 조회

	SELECT A.거래처회사명, A.회사주소, A.회사전화
		 , B.거래처직원명, B.직급, B.이메일, B.휴대폰
	FROM 회사 A, 직원 B
	WHERE A.회사ID = B.회사ID;

*/

/*
   가정) 서울 여의도 LG라는 회사에 근무하는 거래처 직원 명단이 
          총 100만 명이라고 가정한다.
          
          어느 날... 『서울 여의도』에 위치한 『LG』 본사가 
          『경기 분당』으로 사옥을 이전하게 되었다.
          
          이로 인해...
          회사 주소는 『경기 분당』으로 바뀌고,
          회사 전화는 『031-1111-2222』로 바뀌게 되었다.
          
          그러면...회사 테이블에서 1건의 회사주소와 회사전화를 변경해야 한다. 
                   --------------------------------------------- (이 부분 수정됨)
          - 이때 수행되어야 할 쿼리문 → UPDATE 구문
          
          UPDATE 회사
          SET 회사주소='경기분당', 회사전화='031-1111-2222'
          WHERE 회사ID=10;
            
          --> 1개 행을 하드디스크상에서 읽어다가 
              ------(이 부분 수정됨)
              메모리에 로드시켜주어야 한다.
              즉, 1 * 40Byte 를 모두
                 -----------(이 부분 수정됨)
              하드 디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
          
              --> 이는 테이블의 설계가 잘된 상황이다. 
                  
                  --> 정규화를 수행하기 이전에는 100만 건을 처리해야 할 업무에서 
                      1건만 처리하면 되는 업무로 바뀐 상황이기 때문에
                      DB서버는 메모리 고갈없이 아주 빠르게 처리될 것이다. 
*/
--------------------------------------------------------------------------------------------------- 16:00
/*

    A. 거래처회사명, 회사전화
    
    
    SELECT 거래처회사명, 회사전화                              | SELECT 거래처회사명, 회사전화
    FROM 회사                                                 | FROM 거래처직원
    --> 3 * 40 Byte                                           | --> 200만 * 70 Byte
    
    
    
    B. 거래처직원명, 직급
    
    SELECT 거래처직원명, 직급                                  | SELECT 거래처회사명, 회사전화
    FROM 직원                                                 | FROM 거래처직원
    --> 200만 * 50 Byte                                       | --> 200만 * 70 Byte
        
    
    C. 거래처회사명, 거래처직원명
    
    SELECT 회사.거래처회사명, 직원.거래처직원명                 | SELECT 거래처회사명, 거래처직원명 
    FROM 회사 JOIN 직원                                        | FROM 거래처직원
         -------------                                        | --> 200만 * 70Byte
       정규화한 이후에는 '회사'와 '직원'을 JOIN 해야 한다.       |
    ON 회사.회사ID = 직원.회사ID                                |    
    --> (3 * 40Byte) + (200만 * 50 Byte)                       |      
    
    */
    

/*

    이 주문테이블은 고객 테이블을 참조하고 있을 것이다.
    주문테이블은 자식테이블로 참조하는 컬럼이 된다.
    
    제품 테이블이 존재할 것이고, 
    그 테이블에는 제품 정보가 있을 것이다. 
    
    여기서 식별자를 갖는 조건으로 P.K를 설정하려 한다.
    4개의 컬럼 중 어떤 컬럼에 지정해야 할까요?
    (P.K 제약조건은 없을수도 있지만, 최대 1 테이블에 1개가 올 수 있다)
    프라이머리키 제약조건을 하나 구성하는데, 단일 일수도 있지만 여러개(복합) 컬럼이 올 수 있다.
                                          ------             ------
                                          싱글 프라이머리키   컴퍼짓 프라이머리키 
                                          ----------------
                                    만약 싱글 프라이머리키 라면 제 2정규화 적용을 하지 않는다. (컴퍼짓 프라이머리키에서만 제 2정규화를 적용함)


        테이블명 : 주문 
    -----------------------------------------------------------------
          고객ID        제품코드            주문일자        주문수량
          +++++++++++++++++++++++++++++++++++++++++
                           (P.K)
    -----------------------------------------------------------------
      CSY1227(조수연) SWK9987(새우깡)  2019-04-02 11:11:11       50
      KHE7733(곽한얼) YPR9987(양파링)  2019-04-02 12:12:12       30
      LJH7755(이지혜) CPI1100(초파이)  2019-04-03 10:12:12       20
      LJH7755(이지혜) SWK9987(새우깡)  2019-04-03 17:00:00       20  
      KHE7733(곽한얼) CPI1100(초파이)  2019-04-04 05:12:12       50  
                             :
                             : 
    -----------------------------------------------------------------
          ▲                                                    ▲
    수연이는 주문을 못한다                            50개씩 주문해야 한다. 51개라든지..
                           ▲
                    새우깡을 한번밖에 못판다 
                                               ▲
                                      동시 주문 못한다, 장바구니 담기 안됨 
    
    ※ 하나의 테이블에 존재하는 PRIMARY KEY 의 최대 갯수는 1개이다.
       하지만, PRIMARY KEY 를 이루는(구성하는) 컬럼의 갯수는
       복수(다수, 여러개)인 것이 가능하다.
       
       컬럼 1개로만 (단일 컬럼) 구성된 PRIMARY KEY 를
       Single Primary Key 라고 부른다. 
       (단일 프라이머리 키)
       
       두 개 이상의 컬럼으로 구성된 PRIMARY KEY를
       Composite Primary Key 라고 부른다.
       (복합 프라이머리 키) 
       
   
     
    ○ 제 2 정규화
    
    --> 제 1 정규화를 마친 결과물에서 PRIMARY KEY 가 SINGLE COLUMN 이라면
        제 2 정규화는 수행하지 않는다
        
        하지만, PRIMARY KEY 가 COMPOSITE COLUMN 이라면
        반.드.시. 제 2 정규화를 수행해야 한다.
        
    --> 식별자가 아닌 컬럼은 식별자 전체 컬럼에 대해 의존적이어야 하는데
        -----------------   ---------------
              지혜            훈의, 상현
        식별자 전체 컬럼이 아닌, 일부 식별자 컬럼에만 의존적이라면, 이를 분리해서 새로 테이블을 생성해 준다.  
                                ---------------                       -------------------          
                                    상현                                  (지혜, 상현)
    
    --> 복합 프라이머리키는 바람직한 상태가 아니다. (반드시 쪼개지게 되어있다.)     
        
                            
    테이블명 : 과목 → 부모테이블
    ------------------------------------------------------------------------------------------
     과목번호   과목명       교수자번호       교수자명        강의실코드       강의실설명
     ++++++++               ++++++++++
     (      F      .            K    ) → PRIMARY KEY 제약조건이 걸려있으면 식별자여야 한다.     
    ------------------------------------------------------------------------------------------
     JV0101     자바기초         21          슈바이처         A301       전산실습관 3층 30석규모 
     JB0102     자바중급         22           테슬라          T502        전자공학관 5층 20석규모
     DB0102     오라클중급       22           테슬라          A201        전산실습관 2층 50석규모
     DB0102     오라클중급       10           장영실          T502        전자공학관 5층 20석규모
     DB0103     오라클고급       22           테슬라          A203        전산실습관 2층 90석규모
     JS0105     JSP심화         10            장영실         101         인문사회관 1층 80석규모
     ------------------------------------------------------------------------------------------
     
     테이블명 : 점수 → 자식테이블
     ---------------------------------------------------------------
       과목번호       교수번호        학번      학생명         점수
       =======================
               (F.K)    
     ---------------------------------------------------------------
        DB0102          22          1902110     이기승         80
        DB0102          22          1902127     윤희진         76
     ---------------------------------------------------------------    
    
    
    
    ○ 제 3 정규화
    
    --> 식별자가 아닌 컬럼이 식별자가 아닌 컬럼에 의존적인 상황이라면 
        이를 분리하여 새로운 테이블을 생성해 주어야 한다.
    
    -----------------------------------------
        강의실코드         강의실설명
    -----------------------------------------   
         A301       전산실습관 3층 30석규모
         T502       전자공학관 5층 20석규모
         A201       전산실습관 2층 50석규모
         T502       전자공학관 5층 20석규모
    -----------------------------------------
    
    
    ※ 관계(Relation)의 종류
    
        ○ 1 : 1
            피할수 있으면 피해야하는 관계
            DB 설계가 잘못되었을 때, 가장 많이 만들어질 관계가 1 : 1 관계이다. 
            
                ex)
                
                < 테이블명 : 회원 >
                
                    복합 index
                -------------------
                 아이디     패스워드    성명      주민번호    전화번호    우편번호    주소  관심카테고리  취미  특기
                superman     1234      이원영     xxxxxxxx     .......                              
                  tman       1234      삼원영     xxxxxxxx     .......
                  xman       1234      사원영     xxxxxxxx     .......
                  bman       1234      오원영     xxxxxxxx     .......
                -------------------
                가장 많이 쓰일 컬럼
                
                왜냐하면? 
                select 패스워드 
                from 회원가입 
                where 아이디=superman 으로 조회될 것이기 때문에.
                
                
                < 테이블명 : 로그인 >
                -------------------
                 아이디     패스워드
                 superman
                   tman
               
                select 패스워드 
                from 로그인  
                where 아이디=superman         
          
    
        ○ 1 : 다
           --> 관계형 데이터베이스에서 추구해야할 관계
               제 1 정규화를 마친 결과물에서 나타내는 바람직한 관계
               관계형 데이터베이스를 활용하는 과정에서 추구해야 하는 관계.
    
            
        ○ 다 : 다
        
              테이블명 : 고객  (다)                               테이블명 : 제품  (다)
            ------------------------------------          ----------------------------------------
             고객번호    고객명     이메일 ....              제품코드     제품명     제품단가 ......
             ++++++++                                      ++++++++
              (P.K)                                         (P.K)
            ------------------------------------          ----------------------------------------
              1100      이원영     .......                    swk        새우깡       1500
              1101      김선아     .......                    ggk        감자깡        700
              1102      임나래     .......                    ggc        자갈치        500
                          :                                                :
                                    
                    ∴ '고객' 과 '제품' 테이블 두개로만 거래가 가능할 것 같지만, 다 : 다 관계이기 때문에 실제로 불가능하다. 
                                                                              -----------
                       '주문등록' 테이블을 만들어  1 : 다 관계로 깨뜨려주어야 한다. 
                                                 -----------
                                                 
                                    테이블명 : 주문등록
                                    ---------------------------------------
                                    고객번호  제품코드   주문일자   주문수량
                                    ---------------------------------------
                                      1100      swk      ......      30
                                      1101      swk      ......      50
                                      
                      ('과목' 과 '학생' 테이블이라면, '수강신청' 이라던지...)

    ○ 제 4 정규화
    
        --> 위에서 확인한 내용과 같이 『다 : 다』 관계를 『1 : 다』관계로 깨뜨리는 과정이
            제 4정규화의 수행과정이다. 
            → 일반적으로 파생 테이블 생성
               → 『다 : 다』 관계를 『1 : 다』 관계로 깨뜨리는 역할 수행


    ○ 역정규화(비정규화)
        
        [강사님 설명]
        ▶ 역정규화는 
        정규화의 공식을 거스르는 것 (비정규화 → 정규화의 부정을 의미한다) 을 역정규화라 한다. 
        
        정규화 과정을 다 마치고 테이블 설계를 끝내도, 데이터가 들어있는 건 아니다.
        지금은 설명을 하기 위해 데이터가 들어있다는 가정에서 나누고 쪼개는 거라 쉽게 느껴지지만, 
        역정규화는 데이터가 없는 (테이블 설계만 마친 상태) 가운데 해야하기 때문에 어렵다. 
        
        ▶ 역정규화는 어려운 이유는 
        지금 데이터가 들어있지 않은 상태인데, 앞으로 어떻게 데이터가 들어있을지 예측해봐야 하기 때문이다. 
        
        어떤 상황이 발생할수 있는지 케이스로 알아보자. → B의 경우에만 역정규화를 수행해야한다.
        
        ▶ 역정규화를 수행하려면, 업무파악을 꼼꼼히 하고 있어야 한다. 프로파일러처럼. 
        실제로 사용하는 업무담당자, 이용자의 이용방식, 업무상 문서처리방식까지 고려해야 DB설계시 반영할 수 있다. 
        
        [강사님 필기]
    
        ▶ A 경우 : 역정규화를 수행하지 않는 것이 바람직한 경우 (Ⅹ)
        
        
        ○ 이해를 돕기 위한 테이블 작성 (부서테이블 레코드가 10개 인경우)
  
        
           테이블명 : 부서                               테이블명 : 사원
           10            10            10                   10      10         10       10         10           10         10
        -----------------------------------------     ---------------------------------------------------------------    ------
         부서번호       부서명         주소              사원번호    사원명     직급      급여      입사일     부서번호   +  부서명
         ++++++++                                      +++++++++                                           ==========
           (P.K)                                         (P.K)                                               (P.K)                                                  
        -----------------------------------------     ---------------------------------------------------------------    ------
                 5000,000개 행                                                    1,000,000개 행
        -----------------------------------------     ---------------------------------------------------------------    ------
                                                                                                            업무 처리과정에서 부서테이블의 부서명만 
                                                                                                            반복해서 조회된다면, 두 테이블을 조인해서 사용하는 방법을 취할 수 있다.
                                                                                                            그러나, 그럴경우 두 테이블이 모두 메모리에 퍼 올려지므로 
                                                                                                            퍼모먼스 
                                                                                                            사원테이블에 부서명을 붙여서 만들자. 
        >> 업무 분석상 조회 결과물
        --------------------------
        부서명  사원명   직급  급여
        --------------------------
         부서    사원    사원  사원 
        
        
        → 『부서』 테이블과 『사원』 테이블을 JOIN 했을 때의 크기
            (부서테이블)   + (사원테이블)
            (10 * 30 Byte) + (1000000 * 60 Byte) = 300 + 60000000 = 60000300 Byte
                                                                                                            
        → 『사원』테이블에서 역정규화를 수행한 후 이 테이블만 읽어올때의 크기
            (즉, 부서테이블의 부서명 컬럼을 사원테이블에 추가한경우)
            1000000 * 70Byte = 70000000Byte
       
       
        ▶ B 경우 : 역정규화를 수행하는 것이 바람직한 경우 (○)
        
        ○ 이해를 돕기 위한 테이블 작성 (위와 같은 조건, 부서테이블 레코드가 50만개 인경우)
  
        
           테이블명 : 부서                               테이블명 : 사원
           10            10            10                   10      10         10       10         10           10         10
        -----------------------------------------     ---------------------------------------------------------------    ------
         부서번호       부서명         주소              사원번호    사원명     직급      급여      입사일     부서번호   +  부서명
         ++++++++                                      +++++++++                                           ==========
           (P.K)                                         (P.K)                                               (P.K)                                                  
        -----------------------------------------     ---------------------------------------------------------------    ------
                  5000,000개 행                                                    1,000,000개 행
        -----------------------------------------     ---------------------------------------------------------------    ------
        
                                                                                                            사원테이블에 부서명을 붙여서 만들자. 
        >> 업무 분석상 조회 결과물
        --------------------------
        부서명  사원명   직급  급여
        --------------------------
         부서    사원    사원  사원 
        
        
        → 『부서』 테이블과 『사원』 테이블을 JOIN 했을 때의 크기
            (부서테이블)   + (사원테이블)
            (5000,000 * 30 Byte) + (1000000 * 60 Byte) = 15000000 + 60000000 = 75000000 Byte
                                                                                                            
        → 『사원』테이블에서 역정규화를 수행한 후 이 테이블만 읽어올때의 크기
            (즉, 부서테이블의 부서명 컬럼을 사원테이블에 추가한경우)
            1000000 * 70Byte = 70000000Byte
  
  
  
  /*
  
  테이블명 : 사원 → 부모테이블
  ---------------------------------------------------------------
    사원번호  사원명     주민번호    입사일     급여    직급.....
    +++++++
     (P.K)
  ---------------------------------------------------------------
     7369    전훈의     9XXXXX-XX   2010-XX    XXX     부장
     7370    유진석     9XXXXX-XX   2011-XX    XXX     차장
     7371    최보라     9XXXXX-XX   2010-XX    XXX     과장
     7372    정임혜     9XXXXX-XX   2010-XX    XXX     대리
     7373    조현우     9XXXXX-XX   2011-XX    XXX     사원    
                            :
                            
  테이블명 : 사원가족 → 자식테이블
  ------------------------------------------
    주민번호    사원번호     관계    성명     
   +++++++++  ==========
     (P.K)      (F.K)
  ------------------------------------------
    9XXXXX-XX   7369       아내   이연희     
    0XXXXX-XX   7369       아들   강동원    
    9XXXXX-XX   7370       아내   아이유      
    9XXXXX-XX   7371       남편   박형식      
                            :
    
    두 테이블간 관찰로 이상한 부분을 찾아보자.
    관계가 문제있을 것 같다. 
    
    (1) PK 가 바뀔때 다른컬럼의 값들도 바뀌는지 먼저 확인할 것 
    (2) 사원테이블의 주민번호는 PK로 잡을 수 있는지? → UNIQUE로 잡을거다
    
    문제가 있는 테이블 구성이다.
    사실 텍스트기반 아닌 코드기반이어야 한다. 
    간과하기 쉬운 부분이고, 문제가 될 수 있는 부분이다. 
  
  ------------------------------------------
                        관계코드
  ------------------------------------------
                            1
                            3
                            1
                            2
    
    ▶『사원가족』테이블의 관계코드와 『사원』테이블의 직급코드계속해서 반복되므로 제1정규화로 분리해야한다. 
    
    
    가족정보등록
    
    관계 : [     ] 사용자입력을 텍스트로 받을 것이 아니라 
                   번호로 선택할 수 있게 구성해야 한다. 

    
    
  */
  